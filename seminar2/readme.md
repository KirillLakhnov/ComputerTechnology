# Семинар 2

Задания заключаются в том, что нужно исправить код преподавателя, разобравшись в нем. [Исходный код]().

## Задание 1-2

Для начала необходимо понять, что такое разделяемая память.

**Разделяемая память** - метод межпроцессного взаимодействия (IPC), то есть способ обмена данными между программами, работающими одновременно. Один процесс создаёт область в оперативной памяти, которая может быть доступна для других процессов.

Техника разделяемой памяти позволяет осуществлять обмен информацией через общий для процессов сегмент памяти без использования системных вызовов ядра. Сегмент разделяемой памяти подключается в свободную часть виртуального адресного пространства процесса. Таким образом, два разных процесса могут иметь разные адреса одной и той же ячейки, подключенной разделяемой памяти.

### Как с ней работать методами языка **С**.

Для начала обратим внимание на механизм **System V IPC**, который был создан для избавления от недостатков **pipe** и **FIFO**. Механизмы входящие в эту группу: разделяемая память, очереди сообщений и семафоры.

--////----////----////----////----////--

Для создания области разделяемой памяти с определенным ключом или доступа к ней по ключу используется системный вызов ``shmget()``.
Подробнее об ``int shmget(key_t key, int size, int shmflg)``:

1. ``key_t key`` - ключ **System V IPC** для сегмента.
2. ``int size`` - размер в байтах создаваемоего или уже существующего сегмента разделяемой памяти.
3. ``int shmflg`` - флаги (играют роль только при создание нового сегмента разделяемой памяти), которые определяют права различных пользователей при доступе к сегменту.

Этот системный вызов возвращает значение дескриптора **System V IPC** для сегмента разделяемой памяти при нормальном завершении и -1 при возникновение ошибки.

После получения дескриптора необходимо включить область разделямой памяти в адресное пространство текущего процесса. Для этого существует системный вызов ``char* shmat(int shmid, char* shmaddr, int shmflg)``:

1. ``int shmid`` - дескриптор **System V IPC** для сегмента разделяемой памяти.
2. ``char* shmaddr`` - в рамках нашей задачи будем передавать этому аргументу значение **NULL**.
3. ``int shmflg`` - в рамках нашей задачи может пнинмать два значения: 0 - для осуществления операций чтения и записи над сегментом; **SHM_RDONLY** - если мы хотим только читать из сегмента.

При нормаленом завершении возвращается адрес сегмента разделяемой памяти в адресном пространстве процесса. При возникновение ошибки возвращается -1.

После окончания использования разделяемой памяти процесс может уменьшить размер своего адресного пространства, исключив из него эту область с помощью системного вызова ``int shmdt(char* shmaddr)``, который возрващает нуль при нормальном завершении и -1 при возникновении ошибки.

Все это нам встречается в **Задание 1**, в котором мы записываем данные из файла в разделяемую память. В **Задание 2** мы должны обратиться к сегменту разделяемой памяти, в который записывали данные в предыдущей программе, и вывести их в консоль.

Здесь у нас появляется новая задача, удаление данных из ранее используемого сегмента разделяемой памяти. Это можно сделать с помощью системного вызова ``int shmctl(int shmid, int cmd, struct shmid_ds* buf)``:

1. ``int shmid`` - дескриптор **System V IPC** для сегмента разделяемой памяти.
2. ``int cmd`` - в рамках нашей задачи - удаления сегмента разделяемой памяти - будем передавать этому аргументу значение **IPC_RMID**.
3. ``struct shmid_ds* buf`` - в рамках нашей задачи этот параметр не используется, поэтому передаем ему значение **NULL**.

При нормаленом завершении возвращается 0, а при возникновение ошибки возвращается -1.

## Задание 3-4

В целом ничего нового в этих заданиях мы не узнаем. Лишь только практикуем работу с использованием **IPC_PRIVATE** в качестве параметра key_t key в shmget(), который приводит к попытке создания нового сегмента разделяемой памяти с ключом, который не совпадает со значением ключа ни одного из уже существующих сегментов и который не может быть получен с помощью функции ftok() ни при одной комбинации ее параметров.

В этом случае для обращения к используемому сегменту разделяемой памяти необходимо всегда запоминать значение дескриптора разделяемой памяти.

## Задание 5

В этом задание мы реализуем чат в двух терминалах. Для этого нам необходимо использовать методы изученные на первом и втором семинаре.








