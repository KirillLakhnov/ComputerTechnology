# Семинар 1

Задания заключаются в том, что нужно исправить код преподавателя, разобравшись в нем. [Исходный код]().

## Задание 1

Первое задание направление на изучение аргументов командной строки.

### Рассмторим программу, написанную ниже:
```C++
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[], char *envp[])
{
    for (int i = 0; envp[i] != NULL; i++) 
    {
        printf("envp[%d]: %s\n", i, envp[i]);
    }
    for (int i = 0; i < argc; i++)
    {
        printf("argv[%d]: %s\n", i, argv[i]);
    }

    return 0;
} 
```

Данная программа показывает, что функция **main** может иметь аргументы. Рассмотрим их:
1. ``int argc`` - целое число, показывающее количество аргументов в argv. Параметр argc всегда больше или равен 1.
2. ``char *argv[]`` - массив строк, представляющих введенные пользователем программы аргументы командной строки. 

По соглашению ``argv[0]`` — это команда, с помощью которой вызывается программа. 
``argv[1]`` — первый аргумент командной строки. 
``argv[argc - 1]`` - последний аргумент из командной строки.
``argv[argc]`` имеет значение NULL.

Также есть третий аргумент ``envp``. Он является не обязательным. Его используют для того, чтобы посмотреть характеристики процесса, запущенного этим ``main()``. 

## Задание 2

### Что такое PID и PPID и для чего они нужны.

**PID** - это идентификатор процесса, который прикрепляется к программе, когда она начинает работать, и может быть полезен, если вам нужно взаимодействовать с процессом тем или иным образом.

**PPID** - это идентификатор родительского процесса, то есть идентификатор процесса, который создал процесс, который проверяется.

### Программа, печатающая значения PPID и PID для текущего процесса:
```C++
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t pid, ppid;
 
    pid = getpid();   // функция, возвращающая индетификатор нашего процесса
    ppid = getppid(); // функция, возвращающая индетификатор родительского процесса
 
    printf("My pid = %d, my ppid = %d\n", (int)pid, (int)ppid);

    return 0;
}
```

## Задание 3

Рассмотрим программу, написанную ниже:
```C++
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t child_pid = fork();

    if (child_pid < 0)
    {
        //Ошибка 
        printf("Ошибка\n");
    } 
    else if (child_pid == 0)
    { 
        //Порожденный процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("pid = %d, ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }
    else 
    {
        //Родительский процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("My pid = %d, my ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }

    return 0;
}
```

Первым делом в глаза бросается функция ``fork()``. Она пораждает новый процесс (child). 
Процесс, в котором был порожден новый процесс, называется родительским.

Важно заметить, что оба процесса выполняют одну и ту же задачу.

Возвращаемые значения функции ``fork()``:
1. Значение меньшее нуля => ошибка выполнения функции. Новый процесс не создан.
2. Нуль => это значение возвращается, в случае выполнения уже порожденного процесса.
3. Значение большего нуля => вернулся идентификатор порожденного процесса в случае выполнения родительского процесса.

В целом основной принцип работы порожденного процесса очень легко понять наглядно, скомпилировав и запустив код выше.

## Задание 4

Посмотрев на [код](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task4.c) в этом задание, обратим внимание на неизвестную нам ранее функцию:
```C++
int execle(const char * __path, const char * __arg0, ...)
```

Имеется ряд похожих функций, которые можно назавать, как ``сеймество exec()``.

Подробнее о каждой из них можно прочитать [на этом сайте](https://it.wikireading.ru/1003). Здесь же давайте рассмотрим функцию из нашего задания.

Аргументы:

1. ``const char * __path`` - путь к исполняемому файлу.
2. ``const char * __arg0`` - массив аргументов командной строки.

В случае нашей функции мы обязаны передать последним аргументом ``envp``, о котором говорили в задание 2. 
Если бы мы использовали функцию ``execl``, то ее аргументы были те же самые, но ``envp`` передавать не обязательно.

Функция ``execle`` запускает исполняемый файл, передавая ему ряд аргументов.
Возвращаемое ею значение сообщяет нам была ли ошибка, или нет.

## Задание 5

В этой программе мы копируем файл с помщью команды ``/bin/cp``.

Для начала давайте обсудим отличия функций ``fopen, fread, fwrite, fclose`` стандартной библиотеки языка си, которые используются для работы с файлами, от идентичных ``open, read, write, close``, которые мы используются в нашем [задание](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task5.c).

По сути функции полностью идентичны. Наглядная разница заключается в том, что в случае ``open, read, write, close`` мы не используем никаких указателей. Функция open возвращает значение типа ``int``, которое называется дескриптором файла. С ним мы и работаем, используя другие подобные функции, не трогая ``FILE*``. 

Для того, чтобы показать наглядную идентичность, я переписал [программу из нашего задания, используя стандартные функции для работы с файлами](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task5std.c).

Теперь поговорим о внутреннем различие данных функций. ``open, read, write, close`` являются системными вызовами в UNIX. Грубо говоря, ``fopen, fread, fwrite, fclose`` -  оболочки над ними. Они необходимы для кросплатформенности кода, так как системные вызовы меняются в разных системах, а оболочки нет.

Подробнее об этом можно почитать [здесь](http://netlib.narod.ru/library/book0003/ch08_00.htm).

## Задание 6

В отличие от предыдущих задач, нам дано только условие задачи. Код пишется полностью с нуля.

### Условие

Создать программу для запуска на двух терминалах для обмена сообщениями между ними через файл - один передаёт(записывает файл) второй получает, можно чтобы он ещё и рассчитывал чего либо (например возводил строку, если это число, в квадрат). Что будет, если запустить более двух териналов на запись и на чтение?

### Реализация

Для начала обсудим системный вызов ``pipe()``, который предназначен для передачи информации с помощью потоковой модели между различными процессами или даже внутри одного процесса в UNIX-подобных системах.

``int pipe(int *fd)`` - создает pip'а внутри операционной системы. 

Параметр fd является указателем на массив из двух целых переменных. При нормальном завершении вызова в первый элемент массива – ``fd[0]`` – будет занесен файловый дескриптор, соответствующий выходному потоку данных pip’а и позволяющий выполнять только операцию чтения, а во второй элемент массива – ``fd[1]`` – будет занесен файловый дескриптор, соответствующий входному потоку данных и позволяющий выполнять только операцию записи.

Системный вызов возвращает значение 0 при нормальном завершении и значение -1 при возникновении ошибок.

**ВАЖНО:** отличие pip'а от файла заключается в том, что прочитанная информация немедленно удаляется из него и не может быть прочитана повторно.

Механизм обмена информацией через ``pipe`` справедлив лишь для родственных процессов, имеющих общего прародителя, и не может использоваться для потогового общения с другими процессами. Для этого в UNIX применяется средство связи ``FIFO``, который во всем подобен ``pipe``, за исключением того, что данные о FIFO получаются не через родственные связи, а через файловую систему.

Для создания ``FIFO`` используеься системный вызов ``mknod()`` или существующий лишь в некоторых версиях UNIX ``mkfifo()``.

Подробнее об ``int mknod(char* path, int mode, int dev)``, как о методе создания FIFO:

1. ``char* path`` - указатель на строку, в которой лежит путь до файла - метки FIFO на диске. Для успешного создания FIFO, этого файла изначально не должно существовать.
2. ``int mode`` - устанавливает атрибуты прав доступа различных категорий пользователей к FIFO. 
3. ``int dev`` - данный параметр в наших условиях не важен, поэтому его можно задать как нуль.

Системный вызов возвращает значение 0 при нормальном завершении и значение -1 при возникновении ошибок.

## Дополнительно

В качестве дополнения обсудим обработку ошибок в си. Рассмотрим файл ``errno.h`` и переменную ``errno``, которая хранит целочисленный код последней ошибки.

Обычно ``errno`` реализуется в виде макроса, разворачивающегося в вызов функции, возвращающей указатель на целочисленный буфер. При запуске программы значение ``errno`` равно нулю. 

Эту переменную можно безопасно использовать в многопоточной среде, так как в каждом потоке существует локальная версия этой переменной. 

### О кодах ошибок

Все коды ошибок имеют положительные значения, и могут использоваться в директивах препроцессора ``#if``. В целях удобства и переносимости заголовочный файл ``<errno.h>`` определяет макросы, соответствующие кодам ошибок. 

Стандарт ISO C определяет следующие коды: 

1. EDOM – (Error domain) ошибка области определения.
2. EILSEQ – (Error invalid sequence) ошибочная последовательность байтов.
3. ERANGE – (Error range) результат слишком велик.

Прочие коды ошибок (несколько десятков) и их описания определены в стандарте POSIX. Кроме того, в спецификациях стандартных функций обычно указываются используемые ими коды ошибок и их описания. 

Также для того, чтобы узнать все коды ошибок можно использовать этот скрипт, написанный на языке **perl**:
```perl
use strict;
use warnings;

use Errno;

foreach my $err (sort keys (%!)) {
    $! = eval "Errno::$err";
    printf "%20s %4d   %s\n", $err, $! + 0, $!
}
```

### Основная функция для работы с ``errno``

``void perror (const char *s)`` - функция выводит сообщение об ошибке в поток сообщений. В начале выводится строка, на которую указывает аргумент функции, затем выводится двоеточие и пробел, затем выводится сообщение об ошибке, соответствующей значению errno. 

Если на момент вызова функции ошибок не зафиксировано или информация о них удалена, то в качестве сообщения об ошибке будет выведено сообщение: Success.
