# Семинар 1

Задания заключаются в том, что нужно исправить код преподавателя, разобравшись в нем. [Исходный код]().

## Задание 1

Первое задание направление на изучение аргументов командной строки.

### Рассмторим программу, написанную ниже:
```C++
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[], char *envp[])
{
    for (int i = 0; envp[i] != NULL; i++) 
    {
        printf("envp[%d]: %s\n", i, envp[i]);
    }
    for (int i = 0; i < argc; i++)
    {
        printf("argv[%d]: %s\n", i, argv[i]);
    }

    return 0;
} 
```

Данная программа показывает, что функция **main** может иметь аргументы. Рассмотрим их:
1. ``int argc`` - целое число, показывающее количество аргументов в argv. Параметр argc всегда больше или равен 1.
2. ``char *argv[]`` - массив строк, представляющих введенные пользователем программы аргументы командной строки. 

По соглашению ``argv[0]`` — это команда, с помощью которой вызывается программа. 
``argv[1]`` — первый аргумент командной строки. 
``argv[argc - 1]`` - последний аргумент из командной строки.
``argv[argc]`` имеет значение NULL.

Также есть третий аргумент ``envp``. Он является не обязательным. Его используют для того, чтобы посмотреть характеристики процесса, запущенного этим ``main()``. 

## Задание 2

### Что такое PID и PPID и для чего они нужны.

**PID** - это идентификатор процесса, который прикрепляется к программе, когда она начинает работать, и может быть полезен, если вам нужно взаимодействовать с процессом тем или иным образом.

**PPID** - это идентификатор родительского процесса, то есть идентификатор процесса, который создал процесс, который проверяется.

### Программа, печатающая значения PPID и PID для текущего процесса:
```C++
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t pid, ppid;
 
    pid = getpid();
    ppid = getppid();
 
    printf("My pid = %d, my ppid = %d\n", (int)pid, (int)ppid);

    return 0;
}
```

Обратим внимание на заголовочный файл ``<unistd.h>``. Для чего он используется?
Дописать...

## Задание 3

Рассмотрим программу, написанную ниже:
```C++
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t child_pid = fork();

    if (child_pid < 0)
    {
        //Ошибка 
        printf("Ошибка\n");
    } 
    else if (child_pid == 0)
    { 
        //Порожденный процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("pid = %d, ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }
    else 
    {
        //Родительский процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("My pid = %d, my ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }

    return 0;
}
```

Первым делом в глаза бросается функция ``fork()``. Она пораждает новый процесс (child). 
Процесс, в котором был порожденн новый процесс, называется родительским.

Важно заметить, что оба процесса выполняют одну и ту же задачу.

Возвращаемые значения функции ``fork()``:
1. Значение меньшее нуля => ошибка выполнения функции. Новый процесс не создан.
2. Нуль => это значение возвращается, в случае выполнения уже порожденного процесса.
3. Значение большего нуля => вернулся идентификатор порожденного процесса в случае выполнения родительского процесса.

В целом основной принцип работы порожденного процесса очень легко понять наглядно, скомпилировав и запустив код выше.

## Задание 4

Посмотрев на [код](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task4.c) в этом задание, обратим внимание на неизвестную нам ранее функцию:
```C++
int execle(const char * __path, const char * __arg0, ...)
```

Имеется ряд похожих функций, которые можно назавать, как ``сеймество exec()``.

Подробнее о каждой из них можно прочитать [на этом сайте](https://it.wikireading.ru/1003). Здесь же давайте рассмотрим функцию из нашего задания.

Аргументы:

1. ``const char * __path`` - путь к исполняемому файлу.
2. ``const char * __arg0`` - массив аргументов командной строки.

В случае нашей функции мы обязаны передать последним аргументом ``envp``, о котором говорили в задание 2. 
Если бы мы использовали функцию ``execl``, то ее аргументы были те же самые, но ``envp`` передавать не обязательно.

Функция ``execle`` запускает исполняемый файл, передавая ему ряд аргументов.
Возвращаемое ею значение сообщяет нам была ли ошибка, или нет.

## Задание 5

В этой программе мы копируем файл с помщью команды ``/bin/cp``.

Для начала давайте обсудим отличия функций ``fopen, fread, fwrite, fclose`` стандартной библиотеки языка си, которые используются для работы с файлами, от идентичных ``open, read, write, close``, которые мы используются в нашем [задание](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task5.c).

По сути функции полностью идентичны. Наглядная разница заключается в том, что в случае ``open, read, write, close`` мы не используем никаких указателей. Функция open возвращает значение типа ``int``, которое называется дескриптором файла. С ним мы и работаем, используя другие подобные функции, не трогая ``FILE*``. 
Для того, чтобы показать наглядную идентичность, я переписал [программу из нашего задания, используя стандартные функции для работы с файлами](https://github.com/KirillLakhnov/ComputerTechnology/blob/main/seminar1/task5std.c).

Теперь поговорим о внутреннем различие данных функций. ``open, read, write, close`` являются системными вызовами в UNIX. Грубо говоря, ``fopen, fread, fwrite, fclose`` -  оболочки над этими системными вызовами. Внутренность этих оболочек отличается в зависимости от системы, то есть эти функции сделаны для кросплатформенности нашего кода для различных систем.

Подробнее об этом можно почитать [здесь](http://netlib.narod.ru/library/book0003/ch08_00.htm).

## Задание 6

В отличие от предыдущих задач, нам дано только условие задачи. Код пишется полностью с нуля.

### Условие

Создать программу для запуска на двух терминалах для обмена сообщениями между ними через файл - один передаёт(записывает файл) второй получает, можно чтобы он ещё и рассчитывал чего либо (например возводил строку, если это число, в квадрат). Что будет, если запустить более двух териналов на запись и на чтение?

### Реализация

Пока в размышлениях.






