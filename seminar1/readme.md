# Семинар 1

## Задание 1

Первое задание направление на изучение аргументов командной строки.

### Рассмторим программу, написанную ниже:
```C++
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char *argv[], char *envp[])
{
    for (int i = 0; envp[i] != NULL; i++) 
    {
        printf("envp[%d]: %s\n", i, envp[i]);
    }
    for (int i = 0; i < argc; i++)
    {
        printf("argv[%d]: %s\n", i, argv[i]);
    }

    return 0;
} 
```

Данная программа показывает, что функция **main** может иметь аргументы. Рассмотрим их:
1. ``int argc`` - целое число, показывающее количество аргументов в argv. Параметр argc всегда больше или равен 1.
2. ``char *argv[]`` - массив строк, представляющих введенные пользователем программы аргументы командной строки. 

По соглашению ``argv[0]`` — это команда, с помощью которой вызывается программа. 
``argv[1]`` — первый аргумент командной строки. 
``argv[argc - 1]`` - последний аргумент из командной строки.
``argv[argc]`` имеет значение NULL.

Также есть третий аргумент ``envp``. Он является не обязательным. Его используют для того, чтобы посмотреть характеристики процесса, запущенного этим ``main()``. 

## Задание 2

### Что такое PID и PPID и для чего они нужны.

**PID** - это идентификатор процесса, который прикрепляется к программе, когда она начинает работать, и может быть полезен, если вам нужно взаимодействовать с процессом тем или иным образом.

**PPID** - это идентификатор родительского процесса, то есть идентификатор процесса, который создал процесс, который проверяется.

### Программа, печатающая значения PPID и PID для текущего процесса:
```C++
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t pid, ppid;
 
    pid = getpid();
    ppid = getppid();
 
    printf("My pid = %d, my ppid = %d\n", pid, ppid);

    return 0;
}
```

Обратим внимание на заголовочный файл ``<unistd.h>``. Для чего он используется?
Дописать...

## Задание 3

Рассмотрим программу, написанную ниже:
```C++
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
    pid_t child_pid = fork();

    if (child_pid < 0)
    {
        //Ошибка 
        printf("Ошибка\n");
    } 
    else if (child_pid == 0)
    { 
        //Порожденный процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("pid = %d, ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }
    else 
    {
        //Родительский процесс
        pid_t pid = getpid();
        pid_t ppid = getppid();

        printf("My pid = %d, my ppid = %d, child_pid = %d\n", (int)pid, (int)ppid, (int)child_pid); 
    }

    return 0;
}
```

Первым делом в глаза бросается функция ``fork()``. Она пораждает новый процесс (child). 
Процесс, в котором был порожденн новый процесс, называется родительским.

Важно заметить, что оба процесса выполняют одну и ту же задачу.

Возвращаемые значения функции ``fork()``:
1. Значение меньшее нуля => ошибка выполнения функции. Новый процесс не создан.
2. Нуль => это значение возвращается, в случае выполнения уже порожденного процесса.
3. Значение большего нуля => вернулся идентификатор порожденного процесса в случае выполнения родительского процесса.

В целом основной принцип работы порожденного процесса очень легко понять наглядно, скомпилировав и запустив код выше.


